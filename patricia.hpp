/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_PATRICIA_HXX_INCLUDED
#define SK_PATRICIA_HXX_INCLUDED

//#define SK_PATRICIA_TRACE

#include <algorithm>
#include <array>
#include <bit>
#include <climits>
#include <cstddef>
#include <cstring>
#include <memory>
#include <optional>
#include <ranges>
#include <span>
#include <utility>

#if defined(SK_PATRICIA_TRACE) && !defined(NDEBUG)

#    include <iostream>
#    include <set>

#    define SK_PATRICIA_TRACE_MSG(...) fmt::print(__VA_ARGS__)
#else
#    define SK_PATRICIA_TRACE_MSG(...) ((void)0)
#endif

#if !defined(NDEBUG) && !defined(SK_PATRICIA_NO_INVARIANTS)
#    include <cassert>
#    if __has_include(<fmt/core.h>)
#        include <fmt/core.h>
#        define SK_PATRICIA_HAVE_FMT
#    endif
#    define SK_PATRICIA_INVARIANT(c) assert(c)
#else
#    define SK_PATRICIA_INVARIANT(c) ((void)0)
#endif

namespace sk {

    using bit_t = std::size_t;

    /*************************************************************************
     *
     * patricia_key: store an std::span<> along with its bit-length.
     *
     */

    struct patricia_key {
        std::span<std::byte const> key;
        bit_t bits = 0;

        patricia_key() noexcept = default;

        // NOLINTNEXTLINE non-explicit constructor
        patricia_key(std::span<std::byte const> key_, bit_t bits_ = 0) noexcept
            : key(key_), bits(bits_ ? bits_ : (key.size() * CHAR_BIT))
        {
            if (bits > 0) {
                std::size_t need_bytes = 1 + ((bits - 1) / CHAR_BIT);

                if (key.size() > need_bytes)
                    key = key.subspan(0, need_bytes);

                SK_PATRICIA_INVARIANT(key.size() >= need_bytes);
            }
        }

        // NOLINTNEXTLINE non-explicit constructor
        patricia_key(char const *string, bit_t bits_ = 0) noexcept
            : patricia_key(as_bytes(std::span(string, std::strlen(string))),
                           bits_)
        {
        }

        patricia_key(patricia_key const &other) noexcept = default;

        template <std::ranges::contiguous_range Range>
        // NOLINTNEXTLINE non-explicit constructor; forwarding constructor
        patricia_key(Range &&r, bit_t bits_ = 0) noexcept
            : patricia_key(
                  as_bytes(std::span<
                           std::add_const_t<std::ranges::range_value_t<Range>>>(
                      r)),
                  bits_)
        {
        }

        auto operator=(patricia_key const &other) noexcept
            -> patricia_key & = default;

        [[nodiscard]] auto size_bytes() const noexcept -> std::size_t
        {
            return key.size();
        }

        [[nodiscard]] auto size_bits() const noexcept -> bit_t
        {
            return bits;
        }

        [[nodiscard]] auto empty() const noexcept -> bool
        {
            return bits == 0;
        }

        [[nodiscard]] auto test_bit(bit_t bit) const noexcept -> bool
        {
            auto byten = bit / CHAR_BIT;
            if (byten >= key.size())
                return false;

            auto byte = static_cast<unsigned>(key[byten]);

            // auto test_mask = 0x80 >> (bit % CHAR_BIT);
            // bool ret = (byte & test_mask) != 0;

            unsigned ret = (byte >> (CHAR_BIT - ((bit % CHAR_BIT) + 1))) & 1;
            return ret;
        }
    };

    namespace detail {

        /*************************************************************************
         * bit_diff()
         */

        inline auto bit_diff(patricia_key const &a,
                             patricia_key const &b) noexcept -> bit_t
        {
            auto mm = std::ranges::mismatch(a.key, b.key);

            bit_t byte = std::distance(a.key.begin(), mm.in1);

            SK_PATRICIA_TRACE_MSG("[bit_diff: alen={} blen={} diff byte={}]\n",
                                  a.size_bytes(),
                                  b.size_bytes(),
                                  byte);

            if (byte == a.size_bytes() || byte == b.size_bytes())
                return byte * CHAR_BIT;

            std::byte diff = a.key[byte] ^ b.key[byte];
            auto match = std::countl_zero(static_cast<unsigned char>(diff));
            return (byte * CHAR_BIT) + match;
        }

    } // namespace detail

    inline auto operator==(patricia_key const &a,
                           patricia_key const &b) noexcept -> bool
    {
        /*
         * This function is performance-critical since it's called on every
         * node lookup; most of the time in find_node() is actually calling
         * this.
         */

        auto a_size_bytes = a.size_bytes();
        auto a_size_bits = a.size_bits();
        auto b_size_bytes = b.size_bytes();
        auto b_size_bits = b.size_bits();

        if (a_size_bits != b_size_bits)
            return false;

        if (a_size_bytes == 0 && b_size_bytes == 0)
            return true;

        if ((a_size_bits % CHAR_BIT) == 0)
            return std::memcmp(a.key.data(), b.key.data(), a_size_bytes) == 0;

        SK_PATRICIA_INVARIANT(a_size_bytes == b_size_bytes);

        std::size_t i = 0;
        for (; i < (a_size_bytes - 1); ++i) {
            SK_PATRICIA_INVARIANT(i < a.key.size());
            SK_PATRICIA_INVARIANT(i < b.key.size());

            if (a.key[i] != b.key[i])
                return false;
        }

        SK_PATRICIA_INVARIANT(i == (a_size_bytes - 1));

        std::byte mask = std::byte{0xFF}
                         << (CHAR_BIT - (a_size_bits % CHAR_BIT));

        SK_PATRICIA_TRACE_MSG("a_bits={}, b_bits={}, mask={:08b}, mod={}\n",
                              a_size_bits,
                              b_size_bits,
                              mask,
                              a_size_bits % CHAR_BIT);

        return ((a.key[i] ^ b.key[i]) & mask) == std::byte{0};
    }

    /*
     * Compare the first a.size_bits() bits of 'a' to 'b'.
     */
    inline auto prefix_compare(patricia_key const &a,
                               patricia_key const &b) noexcept -> bool
    {
        auto size_bytes = a.size_bytes();
        auto bits = a.size_bits();

        if (bits > b.size_bits())
            return false;

        if (size_bytes == 0)
            return true;

        if ((bits % CHAR_BIT) == 0)
            return std::memcmp(a.key.data(), b.key.data(), size_bytes) == 0;

        SK_PATRICIA_INVARIANT(a.size_bytes() <= b.size_bytes());

        std::size_t i = 0;
        for (; i < (size_bytes - 1); ++i) {
            SK_PATRICIA_INVARIANT(i < a.key.size());
            SK_PATRICIA_INVARIANT(i < b.key.size());

            if (a.key[i] != b.key[i])
                return false;
        }

        SK_PATRICIA_INVARIANT(i == (size_bytes - 1));

        std::byte mask = std::byte{0xFF} << (CHAR_BIT - (bits % CHAR_BIT));

        SK_PATRICIA_TRACE_MSG(
            "bits={}, mask={:08b}, mod={}\n", bits, mask, bits % CHAR_BIT);

        return ((a.key[i] ^ b.key[i]) & mask) == std::byte{0};
    }

    /*************************************************************************
     *
     * patricia_node<T>: one node in the trie that stores an object of type T.
     *
     */

    template <typename T, typename Allocator>
    class patricia_node { // NOLINT uninitialized field
        patricia_node() noexcept = default;

    public:
        using node_ptr = patricia_node<T, Allocator> *;
        using const_node_ptr = patricia_node<T, Allocator> const *;

        using allocator_type = typename std::allocator_traits<
            Allocator>::template rebind_alloc<std::byte>;

        enum edge { left = 0, right = 1 };

        static auto make_node(patricia_key const &key = {}, bit_t bit = 0)
            -> node_ptr
        {
            allocator_type allocator;

            auto bytes = allocator.allocate(
                sizeof(patricia_node<T, Allocator>) + (key.size_bytes() - 1));

            auto ptr = new (bytes) patricia_node<T, Allocator>;
            ptr->bit = bit;

            if (!key.empty()) {
                std::ranges::copy(key.key, &ptr->_key_bytes[0]);
                ptr->key = patricia_key(
                    std::span(&ptr->_key_bytes[0], key.size_bytes()),
                    key.size_bits());
            }

            SK_PATRICIA_TRACE_MSG("[NODE] make node @ {}\n", (void *)ptr);

            return ptr;
        }

        // NOLINTNEXTLINE missing operator new
        static void operator delete(void *ptr) noexcept
        {
            allocator_type allocator;

            auto node = static_cast<patricia_node<T, Allocator> *>(ptr);

            SK_PATRICIA_TRACE_MSG("[NODE] delete node @ {}\n", ptr);

            auto bytes = reinterpret_cast<std::byte *>(ptr);
            allocator.deallocate(bytes,
                                 sizeof(patricia_node<T, Allocator>) +
                                     (node->key.size_bytes() - 1));
        }

        static auto make_node(patricia_node *parent,
                              patricia_node *l,
                              patricia_node *r,
                              bit_t bit)
        {
            auto node = make_node({}, bit);
            node->parent = parent;

            node->edges[left] = l;
            if (l)
                l->parent = node;

            node->edges[right] = r;
            if (r)
                r->parent = node;

            SK_PATRICIA_TRACE_MSG("[make_node: node<{}>, parent<{}>/<{}>, "
                                  "left<{}>/<{}>, right<{}>/<{}>]\n",
                                  (void *)node,
                                  (void *)parent,
                                  (void *)node->parent,
                                  (void *)l,
                                  (void *)(l ? l->parent : nullptr),
                                  (void *)r,
                                  (void *)(r ? r->parent : nullptr));
            return node;
        }

        auto copy() const -> patricia_node *
        {
            auto new_node = make_node(key, bit);
            new_node->value = value;
            new_node->parent = parent;

            if (edges[left])
                new_node->edges[left] = edges[left]->copy();

            if (edges[right])
                new_node->edges[right] = edges[right]->copy();

            return new_node;
        }

        patricia_node(patricia_node const &) = delete;
        patricia_node(patricia_node &&) = delete;
        auto operator=(patricia_node const &) = delete;
        auto operator=(patricia_node &&) = delete;

        ~patricia_node() noexcept(std::is_nothrow_destructible_v<T>)
        {
            delete edges[0];
            delete edges[1];
        }

        void clear_value() noexcept(std::is_nothrow_destructible_v<T>)
        {
            // Can't reset the key because we need to know its byte length
            // for operator delete.
            key.bits = 0;
            value.reset();
        }

        [[nodiscard]] auto edgecount() const noexcept -> int
        {
            return static_cast<int>(2 - std::ranges::count(edges, nullptr));
        }

        [[nodiscard]] auto leftedge() noexcept -> node_ptr &
        {
            return edges[left];
        }

        [[nodiscard]] auto leftedge() const noexcept -> const_node_ptr
        {
            return edges[left];
        }

        [[nodiscard]] auto rightedge() noexcept -> node_ptr &
        {
            return edges[right];
        }

        [[nodiscard]] auto rightedge() const noexcept -> const_node_ptr
        {
            return edges[right];
        }

        // Detach the left or right edge from this node and return it.
        auto detach(edge e) noexcept -> node_ptr
        {
            if (!edges[e])
                return nullptr;

            auto *p = std::exchange(edges[e], nullptr);
            p->parent = nullptr;
            return p;
        }

        // Attach a new node to this one.  If an existing node was present,
        // detach and return it.
        auto attach(edge e, node_ptr n) noexcept -> node_ptr
        {
            SK_PATRICIA_TRACE_MSG(
                "[attach: node<{}> gains n<{}> at {}, replaces <{}>]\n",
                (void *)this,
                (void *)n,
                e == left ? "left" : "right",
                (void *)edges[e]);
            auto prev = detach(e);
            edges[e] = n;
            n->parent = this;
            return prev;
        }

        // Return whether the given node is our left or right edge.
        auto which(node_ptr n) const noexcept -> edge
        {
            if (leftedge() == n)
                return left;
            else {
                SK_PATRICIA_INVARIANT(rightedge() == n);
                return right;
            }
        }

        bit_t bit = 0;
        std::array<node_ptr, 2> edges{};
        patricia_node *parent = nullptr;
        std::optional<T> value;
        patricia_key key;
        std::byte _key_bytes[1]; // must be the last member
    };

    /*************************************************************************
     *
     * patricia_iterator<T>: an iterator for a patricia_trie.
     *
     */

    template <typename T,
              typename Alloc = std::allocator<T>,
              bool is_const_iterator = false>
    class patricia_iterator {
        using node_type = patricia_node<T, Alloc>;
        using node_pointer = std::
            conditional_t<is_const_iterator, node_type const *, node_type *>;
        using const_node_pointer = node_type const *;

        node_pointer current = nullptr;

        auto _advance() noexcept -> void
        {
            do {
                SK_PATRICIA_TRACE_MSG("iterator: at {}\n", (void *)current);

                if (current->leftedge()) {
                    current = current->leftedge();
                    continue;
                }

                if (current->rightedge()) {
                    current = current->rightedge();
                    continue;
                }

                // If we can't go either left or right, back up until we
                // find a node where we went left last time and can go
                // right this time.  If we walk up to the root and don't
                // find any right branch, stop iterating.
                for (;;) {
                    SK_PATRICIA_TRACE_MSG("iterator: walking up, current={}\n",
                                          (void *)current);
                    auto here_is_left =
                        (current == current->parent->leftedge());
                    auto parent_has_right =
                        (current->parent->rightedge() != nullptr);

                    if (here_is_left && parent_has_right) {
                        current = current->parent->rightedge();
                        break;
                    }

                    current = current->parent;
                    if (!current->parent) {
                        SK_PATRICIA_TRACE_MSG(
                            "iterator: at root and nowhere to go\n");
                        current = nullptr;
                        return;
                    }
                }
            } while (current && !current->value);
        }

    public:
        using iterator_category = std::forward_iterator_tag;
        using difference_type = std::ptrdiff_t;
        using value_type =
            std::conditional_t<is_const_iterator, std::add_const_t<T>, T>;
        using const_value_type = std::add_const_t<value_type>;
        using pointer = value_type *;
        using const_pointer = const_value_type *;
        using reference = value_type &;
        using const_reference = const_value_type &;

        explicit patricia_iterator() noexcept = default;

        explicit patricia_iterator(node_pointer node) noexcept : current(node)
        {
            if (current && !current->value)
                _advance();
        }

        auto operator*() noexcept -> reference
        {
            SK_PATRICIA_INVARIANT(current != nullptr &&
                                  current->value.has_value());
            return *current->value;
        }

        auto operator*() const noexcept -> const_reference
        {
            SK_PATRICIA_INVARIANT(current != nullptr &&
                                  current->value.has_value());
            return *current->value;
        }

        auto operator->() noexcept -> pointer
        {
            SK_PATRICIA_INVARIANT(current != nullptr &&
                                  current->value.has_value());
            return std::addressof(*current->value);
        }

        auto operator->() const noexcept -> const_pointer
        {
            SK_PATRICIA_INVARIANT(current != nullptr &&
                                  current->value.has_value());
            return std::addressof(*current->value);
        }

        auto operator++() noexcept -> patricia_iterator &
        {
            _advance();
            return *this;
        }

        auto operator++(int) noexcept -> patricia_iterator
        {
            auto ret(*this);
            ++*this;
            return ret;
        }

        auto get_node() const noexcept -> node_pointer
        {
            return current;
        }

        template <typename T_, typename Alloc_, bool is_const_>
        friend auto
        operator==(patricia_iterator<T_, Alloc_, is_const_> const &a,
                   patricia_iterator<T_, Alloc_, is_const_> const &b) noexcept
            -> bool;
    };

    template <typename T, typename Alloc, bool is_const>
    auto operator==(patricia_iterator<T, Alloc, is_const> const &a,
                    patricia_iterator<T, Alloc, is_const> const &b) noexcept
        -> bool
    {
        SK_PATRICIA_TRACE_MSG("iterator::op==: a.current={} b.current={}\n",
                              (void *)a.current,
                              (void *)b.current);
        return a.current == b.current;
    }

    /*************************************************************************
     *
     * patricia_trie<T>: a trie that stores objects of type T.
     *
     */

    template <typename T, typename Alloc = std::allocator<T>>
    class patricia_trie {
    public:
        using key_type = patricia_key;

        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;

        using value_type = T;
        using const_value_type = value_type const;

        using reference = value_type &;
        using const_reference = const_value_type &;
        using pointer = value_type *;
        using const_pointer = const_value_type *;

        using node_type = patricia_node<value_type, Alloc>;
        using const_node_type = node_type const;

        using value_pointer = value_type *;
        using const_value_pointer = value_type const *;

        using node_pointer = node_type *;
        using const_node_pointer = node_type const *;

        using iterator = patricia_iterator<T, Alloc, false>;
        using const_iterator = patricia_iterator<T, Alloc, true>;

    private:
        node_pointer root = nullptr;

    public:
        patricia_trie() noexcept = default;
        patricia_trie(patricia_trie &&) noexcept;
        patricia_trie(patricia_trie const &);
        ~patricia_trie() noexcept(std::is_nothrow_destructible_v<node_type>);

        auto operator=(patricia_trie &&) noexcept -> patricia_trie &;
        auto operator=(patricia_trie const &) -> patricia_trie &;

        // Node operations.
        [[nodiscard]] auto find_node(patricia_key const &key) const noexcept
            -> const_node_pointer;

        [[nodiscard]] auto find_node(patricia_key const &key) noexcept
            -> node_pointer;

        [[nodiscard]] auto prefix_match(patricia_key const &key) noexcept
            -> node_pointer;

        auto insert_node(patricia_key const &key) -> node_pointer;

        auto remove_node(node_pointer) noexcept(
            std::is_nothrow_destructible_v<node_type>) -> void;

        [[nodiscard]] auto root_node() noexcept -> node_pointer;
        [[nodiscard]] auto root_node() const noexcept -> const_node_pointer;

        // Iterator operations.
        auto begin() noexcept -> iterator;
        auto begin() const noexcept -> const_iterator;
        auto cbegin() const noexcept -> const_iterator;

        auto end() noexcept -> iterator;
        auto end() const noexcept -> const_iterator;
        auto cend() const noexcept -> const_iterator;

        [[nodiscard]] auto find(patricia_key const &key) const noexcept
            -> const_iterator;

        [[nodiscard]] auto find(patricia_key const &key) noexcept -> iterator;

        auto erase(iterator const &) noexcept(
            std::is_nothrow_destructible_v<node_type>) -> size_type;

        // Value operations.
        auto insert(patricia_key const &key, T const &value) -> bool;

        auto remove(patricia_key const &key) noexcept(
            std::is_nothrow_destructible_v<node_type>) -> bool;

        auto clear() noexcept(std::is_nothrow_destructible_v<node_type>)
            -> void;

        [[nodiscard]] auto empty() const noexcept -> bool;

        // Debugging functions.
#ifdef SK_PATRICIA_INVARIANT

        template <typename... Args>
        void bugcheck(std::string const &, Args &&...args) const noexcept;

#endif

#ifdef SK_PATRICIA_TRACE
        [[nodiscard]] auto format_key(patricia_key const &k) const
            -> std::string;

        auto print(const_node_pointer node, int indent = 0) const
            -> std::string;

        auto
        check(const_node_pointer node,
              std::shared_ptr<std::set<const_node_pointer>> seen = {}) const
            -> void;
#endif // SK_PATRICIA_TRACE
    };

    /*************************************************************************
     * patrcia_trie<T> copy constructor
     */
    template <typename T, typename Allocator>
    patricia_trie<T, Allocator>::patricia_trie(patricia_trie const &other)
        : root(other.root->copy())
    {
    }

    /*************************************************************************
     * patrcia_trie<T> move constructor
     */
    template <typename T, typename Allocator>
    patricia_trie<T, Allocator>::patricia_trie(patricia_trie &&other) noexcept
        : root(std::exchange(other.root, nullptr))
    {
    }

    /*************************************************************************
     * patrcia_trie<T> copy assignment
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::operator=(patricia_trie const &other)
        -> patricia_trie &
    {
        if (&other != this) {
            delete root;
            root = other.root->copy();
        }

        return *this;
    }

    /*************************************************************************
     * patrcia_trie<T> move assignment
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::operator=(patricia_trie &&other) noexcept
        -> patricia_trie &
    {
        if (&other != this)
            root = std::exchange(other.root, nullptr);
        return *this;
    }

    /*************************************************************************
     * patricia_trie<T>::~patricia_trie
     */
    template <typename T, typename Alloc>
    patricia_trie<T, Alloc>::~patricia_trie() noexcept(
        std::is_nothrow_destructible_v<node_type>)
    {
        delete root;
    }

    /*************************************************************************
     * iterators
     */

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::begin() noexcept -> iterator
    {
        return iterator(root);
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::begin() const noexcept -> const_iterator
    {
        return const_iterator(root);
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::cbegin() const noexcept -> const_iterator
    {
        return const_iterator(root);
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::end() noexcept -> iterator
    {
        return iterator();
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::end() const noexcept -> const_iterator
    {
        return const_iterator();
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::cend() const noexcept -> const_iterator
    {
        return const_iterator();
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::root_node() noexcept -> node_pointer
    {
        return root;
    }

    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::root_node() const noexcept
        -> const_node_pointer
    {
        return root;
    }

    /*************************************************************************
     * patricia_trie<T>::clear
     */
    template <typename T, typename Alloc>
    auto patricia_trie<T, Alloc>::clear() noexcept(
        std::is_nothrow_destructible_v<node_type>) -> void
    {
        delete std::exchange(root, nullptr);
    }

    /*************************************************************************
     * patricia_trie<T>::empty
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::empty() const noexcept -> bool
    {
        return !root || (!root->value && !root->edges[0] && !root->edges[1]);
    }

    /*************************************************************************
     * patricia_trie<T>::insert
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::insert(patricia_key const &key,
                                             T const &value) -> bool
    {
        auto node = insert_node(key);

        if (node->value)
            return false;

        node->value = value;
        return true;
    }

    /*************************************************************************
     * patricia_trie<T>::find_node
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::find_node(
        patricia_key const &key) const noexcept -> const_node_pointer
    {
        // const_cast is safe here because _get_node doesn't modify the trie
        // when the op is find.  however, this should probably be refactored.
        return const_cast<patricia_trie<T, Allocator> *>(this)->find_node(key);
    }

    /*************************************************************************
     * patricia_trie<T>::find
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::find(patricia_key const &key) noexcept
        -> iterator
    {
        auto node = find_node(key);

        if (!node || !node->value)
            return iterator();

        return iterator(node);
    }

    template <typename T, typename Allocator>
    auto
    patricia_trie<T, Allocator>::find(patricia_key const &key) const noexcept
        -> const_iterator
    {
        auto node = find_node(key);

        if (!node || !node->value)
            return const_iterator();

        return const_iterator(node);
    }

    template<typename T, typename Alloc> auto patricia_trie<T, Alloc>::erase(
        iterator const &it) noexcept(std::is_nothrow_destructible_v<node_type>)
        -> size_type
    {
        SK_PATRICIA_TRACE_MSG("\n[REMOVE] call _get_node\n");

#ifdef SK_PATRICIA_TRACE
        check(root);
#endif

        remove_node(it.get_node());
        return 1;

#ifdef SK_PATRICIA_TRACE
        check(root);
#endif
        return true;
    }

    /*************************************************************************
     * patricia_trie<T>::remove
     */
    template <typename T, typename Alloc>
    auto patricia_trie<T, Alloc>::remove(patricia_key const &key) noexcept(
        std::is_nothrow_destructible_v<node_type>) -> bool
    {
        auto it = find(key);
        if (it == end())
            return false;
        erase(it);
        return true;
    }

#ifdef SK_PATRICIA_INVARIANT

    /*************************************************************************
     * patricia_trie<T>::bugcheck
     */
#    ifdef SK_PATRICIA_HAVE_FMT
    template <typename T, typename Allocator>
    template <typename... Args>
    void patricia_trie<T, Allocator>::bugcheck(std::string const &format,
                                               Args &&...args) const noexcept
    {
        std::string msg = fmt::format(format, std::forward<Args>(args)...);
        fmt::print("[BUGCHECK] {}\n\n", msg);
#        ifdef SK_PATRICIA_TRACE
        fmt::print("Trie state:\n\n{}\n", print(root));
#        endif
        SK_PATRICIA_INVARIANT(!"invariant failed");
    }
#    else
    template <typename T, typename Allocator>
    template <typename... Args>
    void patricia_trie<T, Allocator>::bugcheck(std::string const &format,
                                               Args &&...) const noexcept
    {
        std::ignore = format;
        SK_PATRICIA_INVARIANT(!format.c_str());
    }
#    endif

#endif

#ifdef SK_PATRICIA_TRACE

    /*************************************************************************
     * patricia_trie<T>::format_key
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::format_key(patricia_key const &k) const
        -> std::string
    {
        auto &key = k.key;

        auto printable = std::ranges::all_of(key, [](auto c) {
            auto u_c = static_cast<int>(static_cast<unsigned char>(c));
            return std::isalpha(u_c) || std::isblank(u_c);
        });

        std::string ret;

        if (printable) {
            for (auto &&b : key)
                ret += static_cast<char>(b);
        } else {
            for (auto &&b : key)
                ret += fmt::format("{:02x}", b);
        }

        ret += "<";
        for (auto &&b : key)
            ret += fmt::format("{:08b}", b);
        ret += ">";
        return ret;
    }

    /*************************************************************************
     * patricia_trie<T>::print
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::print(const_node_pointer node,
                                            int indent) const -> std::string
    {
        auto pad = std::string(indent, ' ');

        if (!node)
            return pad + "<null>\n";

        std::string left, right;

        if (node->edges[0])
            left = pad + "|--left:\n" + print(node->edges[0], indent + 4);
        if (node->edges[1])
            right = pad + "|--right:\n" + print(node->edges[1], indent + 4);

        return fmt::format("{}node<{}> [bit {}] key=[{}]: parent<{}>\n{}{}",
                           pad,
                           (void *)node,
                           node->bit,
                           format_key(node->key),
                           (void *)node->parent,
                           left,
                           right);
    }

    /*************************************************************************
     * patricia_trie<T>::check
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::check(
        const_node_pointer node,
        std::shared_ptr<std::set<const_node_pointer>> seen) const -> void
    {
        bool top = !seen;

        if (top)
            seen = std::make_shared<std::set<const_node_pointer>>();

        if (!seen->insert(node).second) {
            fmt::print("[check: FAILED: node<{}> is in the tree twice]\n",
                       (void *)node);
            SK_PATRICIA_INVARIANT(!"invariant failed");
        }

        if (top && node->parent) {
            fmt::print("[check: FAILED: root node<{}> has parent]\n",
                       (void *)node);
            SK_PATRICIA_INVARIANT(!"invariant failed");
        }

        if (!top && !node->parent) {
            fmt::print("[check: FAILED: sub node<{}> has no parent]\n",
                       (void *)node);
            SK_PATRICIA_INVARIANT(!"invariant failed");
        }

        if (node->parent) {
            if (node->parent->edges[0] != node &&
                node->parent->edges[1] != node) {
                fmt::print("[check: FAILED: node<{}> is not a child of "
                           "parent<{}>]\n",
                           (void *)node,
                           (void *)node->parent);
                SK_PATRICIA_INVARIANT(!"invariant failed");
            }

            if (node->parent->edges[0] == node &&
                node->parent->edges[1] == node) {
                fmt::print("[check: FAILED: node<{}> is both left and "
                           "right child of parent<{}>]\n",
                           (void *)node,
                           (void *)node->parent);
                SK_PATRICIA_INVARIANT(!"invariant failed");
            }
        }

        if (node->edges[0])
            check(node->edges[0], seen);

        if (node->edges[1])
            check(node->edges[1], seen);

        if (top)
            fmt::print("[check: ok]\n");
    }

#endif // SK_PATRICIA_TRACE

    /*************************************************************************
     * patricia_trie<T>::_remove_node
     */
    template <typename T, typename Alloc>
    auto patricia_trie<T, Alloc>::remove_node(node_pointer node) noexcept(
        std::is_nothrow_destructible_v<node_type>) -> void
    {
        // Removing this node may cause the parent to be deleted as well, so
        // loop until we find a node we can't delete.
        do {
            SK_PATRICIA_TRACE_MSG(
                "_remove_node: remove node<{}>, parent={} root={}\n",
                (void *)node,
                (void *)node->parent,
                (void *)root);
            SK_PATRICIA_TRACE_MSG("            : trie state:\n{}", print(root));

            /*
             * If this node has two child nodes, don't delete it; set the
             * value to null.
             */
            if (node->edgecount() == 2) {
                SK_PATRICIA_TRACE_MSG(
                    "            : node has two children, value?={}\n",
                    node->value.has_value());

                node->clear_value();
                return;
            }

            /*
             * If this node is the root, make its child (if any) the new root.
             */
            if (node == root) {
                SK_PATRICIA_TRACE_MSG("            : node is the root:\n");
                SK_PATRICIA_TRACE_MSG("            :   left={}\n",
                                      (void *)node->leftedge());
                SK_PATRICIA_TRACE_MSG("            :   right={}\n",
                                      (void *)node->rightedge());

                SK_PATRICIA_INVARIANT(!node->parent);
                SK_PATRICIA_INVARIANT(node->edgecount() <= 1);

                if (node->value)
                    node->clear_value();

                if (node->leftedge())
                    root = node->detach(node_type::left);
                else if (node->rightedge())
                    root = node->detach(node_type::right);
                else
                    return;

                delete node;
                SK_PATRICIA_TRACE_MSG("            : new root={}\n",
                                      (void *)root);
                return;
            }

            if (node->edgecount() == 0) {
                /*
                 * Node has no children.
                 */
                SK_PATRICIA_TRACE_MSG(
                    "            : node is childless and without value\n");

                SK_PATRICIA_INVARIANT(node->parent->leftedge() == node ||
                                      node->parent->rightedge() == node);

                node->parent->edges[node->parent->which(node)] = nullptr;
                delete std::exchange(node, node->parent);
            } else {
                /*
                 * This node is not the root and has exactly one child. Reparent
                 * the child to the node's parent.
                 */
                auto *p = node->parent;

                SK_PATRICIA_TRACE_MSG(
                    "            : node has one child, reparent child "
                    "to node's "
                    "parent:\n");
                SK_PATRICIA_TRACE_MSG("            :   left={}\n",
                                      (void *)node->edges[0]);
                SK_PATRICIA_TRACE_MSG("            :   right={}\n",
                                      (void *)node->edges[1]);
                SK_PATRICIA_TRACE_MSG("            :   parent->left={}\n",
                                      (void *)node->parent->edges[0]);
                SK_PATRICIA_TRACE_MSG("            :   parent->right={}\n",
                                      (void *)node->parent->edges[1]);

                node->parent->attach(node->parent->which(node),
                                     node->detach(node->leftedge()
                                                      ? node_type::left
                                                      : node_type::right));
                delete std::exchange(node, p);
            }
        } while (!node->value && !(node->edges[0] && node->edges[1]));
    }

    /*************************************************************************
     * patricia_trie<T>::find_node
     */
    template <typename T, typename Allocator>
    auto
    patricia_trie<T, Allocator>::find_node(patricia_key const &key) noexcept
        -> node_pointer
    {
        SK_PATRICIA_TRACE_MSG("find_node: start search, root={}\n",
                              (void *)root);

        if (!root)
            return nullptr;

        auto node = root;
        auto keybits = key.size_bits();

        // Find the node in the trie.
        while (node->bit < keybits) {
            auto &next = node->edges[key.test_bit(node->bit)];

            if (!next)
                break;

            node = next;
        }

        if (key == node->key)
            return node;

        return nullptr;
    }

    /*************************************************************************
     * patricia_trie<T>::upper_bound
     */
    template <typename T, typename Allocator>
    auto
    patricia_trie<T, Allocator>::prefix_match(patricia_key const &key) noexcept
        -> node_pointer
    {
        SK_PATRICIA_TRACE_MSG("prefix_match: start search key<{}>, root={}\n",
                              format_key(key),
                              (void *)root);
        if (!root)
            return nullptr;

        SK_PATRICIA_TRACE_MSG("{}\n", print(root));

        auto node = root;
        auto keybits = key.size_bits();

        while (node->bit < keybits) {
            SK_PATRICIA_TRACE_MSG(
                "prefix_match: at {}, node->bit={}\n", (void *)node, node->bit);

            auto &next = node->edges[key.test_bit(node->bit)];

            SK_PATRICIA_TRACE_MSG("prefix_match: <{}> <{}>\n",
                                  format_key(key),
                                  format_key(node->key));

            if (!next)
                break;

            node = next;
        }

        SK_PATRICIA_TRACE_MSG("prefix_match: search [{}] found node<{}> [{}]\n",
                              format_key(key),
                              (void *)node,
                              format_key(node->key));

        // Walk up the tree until we find a match.
        while (node != nullptr &&
               (node->key.bits > keybits || !prefix_compare(node->key, key))) {
            SK_PATRICIA_TRACE_MSG("prefix_match: no match at node<{}>\n    "
                                  "node={},\n     key={}\n",
                                  (void *)node,
                                  format_key(node->key),
                                  format_key(key));
            node = node->parent;
        }

        if (node)
            SK_PATRICIA_TRACE_MSG(
                "prefix_match: match at node<{}>\n    node={},\n     key={}\n",
                (void *)node,
                format_key(node->key),
                format_key(key));

        return node;
    }

    /*************************************************************************
     * patricia_trie<T>::_get_node
     */
    template <typename T, typename Allocator>
    auto patricia_trie<T, Allocator>::insert_node(patricia_key const &key)
        -> node_pointer
    {
        auto keylen = key.size_bits();

        if (!root)
            root = node_type::make_node();

        auto node = root;

        // Find the node in the trie.

        while (node->bit < keylen || !node->value) {
            auto &next = node->edges[key.test_bit(node->bit)];

            if (!next)
                break;

            node = next;
        }

        auto check_bit = (node->bit < keylen) ? node->bit : keylen;
        bit_t diffbit = detail::bit_diff(key, node->key);
        if (diffbit > check_bit)
            diffbit = check_bit;

        while (node->parent && (node->parent->bit >= diffbit))
            node = node->parent;

        if (diffbit == keylen && node->bit == keylen)
            return node;

        auto new_node = node_type::make_node(key, keylen);

        if (node->bit == diffbit) {
            new_node->parent = node;

            bool bit = key.test_bit(node->bit);
            node->attach(static_cast<typename node_type::edge>(bit), new_node);
            return new_node;
        }

        if (keylen == diffbit) {
            new_node->parent = node->parent;

            bool bit = node->key.test_bit(keylen);

            if (!node->parent)
                delete std::exchange(root, new_node);
            else
                new_node->edges[bit] = std::exchange(
                    node->parent->edges[node->parent->which(node)], new_node);

            node->parent = new_node;
            return new_node;
        }

        bool bit = key.test_bit(diffbit);

        auto *old_parent = node->parent;

        auto n = node_type::make_node(node->parent,
                                      bit ? node : new_node,
                                      bit ? new_node : node,
                                      diffbit);

        // n->bit = diffbit;

        // if (n->parent)
        old_parent->attach(old_parent->which(node), n);
        // attach() calls detach() which resets node->parent
        node->parent = n;
        return new_node;
    }

    template <typename T>
    struct patricia_key_maker {
        template <typename U>
        struct rebind {
            using other = patricia_key_maker<U>;
        };

        auto operator()(T const &v) noexcept -> patricia_key
        {
            return patricia_key(v);
        }
    };

    template <std::unsigned_integral T>
    struct patricia_key_maker<T> {
        template <typename U>
        struct rebind {
            using other = patricia_key_maker<U>;
        };

        std::byte buf[sizeof(T)];

        patricia_key_maker() noexcept = default;

        auto operator()(T v) noexcept -> patricia_key
        {
            if constexpr (std::endian::native == std::endian::big)
                std::memcpy(buf.data(), &v, sizeof(T));
            else {
                std::byte *ptr = &buf[0];

                for (unsigned i = 0; i < sizeof(T); ++i)
                    *ptr++ = static_cast<std::byte>(
                        v >> (CHAR_BIT * (sizeof(T) - (i + 1))) & 0xFF);
            }

            return patricia_key(buf);
        }
    };

    template <std::signed_integral T>
    struct patricia_key_maker<T> {
        template <typename U>
        struct rebind {
            using other = patricia_key_maker<U>;
        };

        using unsigned_type = std::make_unsigned_t<T>;
        patricia_key_maker<unsigned_type> km;

        patricia_key_maker() noexcept = default;

        auto operator()(T v) noexcept -> patricia_key
        {
            // Convert the signed value to a sorted unsigned
            unsigned_type u;
            if (v < 0)
                u = static_cast<unsigned_type>(-std::numeric_limits<T>::min()) +
                    v;
            else
                u = static_cast<unsigned_type>(v) +
                    -std::numeric_limits<T>::min();

            SK_PATRICIA_TRACE_MSG("signed key_maker> v={:0x}, u={:0x}\n", v, u);

            return km(u);
        }
    };

    /*************************************************************************
     *
     * patricia_set<T>: an std::set<>-type container using a patricia trie.
     */

    template <typename T, typename Alloc, bool is_const>
    class patricia_set_iterator {
        using iterator_type = patricia_iterator<T, Alloc, is_const>;
        using node_type = patricia_node<T, Alloc>;
        using node_pointer =
            std::conditional_t<is_const, node_type const *, node_type *>;
        iterator_type current;

    public:
        using iterator_category = typename iterator_type::iterator_category;
        using difference_type = typename iterator_type::difference_type;
        using value_type = std::conditional_t<is_const, std::add_const_t<T>, T>;
        using const_value_type = std::add_const_t<value_type>;
        using pointer = value_type *;
        using const_pointer = const_value_type *;
        using reference = value_type &;
        using const_reference = const_value_type &;

        explicit patricia_set_iterator() noexcept = default;

        explicit patricia_set_iterator(node_pointer node) noexcept
            : current(iterator_type(node))
        {
        }

        auto operator*() noexcept -> reference
        {
            return *current;
        }

        auto operator*() const noexcept -> const_reference
        {
            return *current;
        }

        auto operator->() noexcept -> pointer
        {
            return std::addressof(*current);
        }

        auto operator->() const noexcept -> const_pointer
        {
            return std::addressof(*current);
        }

        auto operator++() noexcept -> patricia_set_iterator &
        {
            ++current;
            return *this;
        }

        auto operator++(int) noexcept -> patricia_set_iterator
        {
            auto ret(*this);
            ++*this;
            return ret;
        }

        template <typename T_, typename Alloc_, bool is_const_>
        friend auto operator==(
            patricia_set_iterator<T_, Alloc_, is_const_> const &a,
            patricia_set_iterator<T_, Alloc_, is_const_> const &b) noexcept
            -> bool;
    };

    template <typename T, typename Alloc, bool is_const>
    auto operator==(patricia_set_iterator<T, Alloc, is_const> const &a,
                    patricia_set_iterator<T, Alloc, is_const> const &b) noexcept
        -> bool
    {
        return a.current == b.current;
    }

    template <typename T,
              typename KeyMaker = patricia_key_maker<T>,
              typename Alloc = std::allocator<T>>
    class patricia_set {
    public:
        using key_type = T;
        using value_type = T;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        using reference = value_type &;
        using const_reference = value_type const &;
        using pointer = typename std::allocator_traits<Alloc>::pointer;
        using const_pointer =
            typename std::allocator_traits<Alloc>::const_pointer;

        using iterator = patricia_set_iterator<T, Alloc, false>;
        using const_iterator = patricia_set_iterator<T, Alloc, true>;

    private:
        using trie_type = patricia_trie<T, Alloc>;
        using node_ptr = patricia_node<T, Alloc> *;
        using const_node_ptr = patricia_node<T, Alloc> const *;

        trie_type _trie;

        auto _insert_node(patricia_key const &key) -> node_ptr
        {
            return _trie.insert_node(key);
        }

        auto _insert_node(value_type const &value) -> node_ptr
        {
            KeyMaker key_maker;
            auto key = key_maker(value);
            return _insert_node(key);
        }

        template <typename V>
        auto _insert_node(V const &value) -> node_ptr
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            return _insert_node(key);
        }

        auto _find_node(patricia_key const &key) noexcept -> node_ptr
        {
            return _trie.find_node(key);
        }

        auto _find_node(patricia_key const &key) const noexcept
            -> const_node_ptr
        {
            return _trie.find_node(key);
        }

        template <typename V>
        auto _find_node(V const &value) noexcept -> node_ptr
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            return _find_node(key);
        }

        template <typename V>
        auto _find_node(V const &value) const noexcept -> const_node_ptr
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            return _find_node(key);
        }

    public:
        patricia_set() noexcept = default;
        ~patricia_set() noexcept(std::is_nothrow_destructible_v<trie_type>) =
            default;

        template <typename input_iterator>
        patricia_set(input_iterator first, input_iterator last)
        {
            while (first != last) {
                insert(*first);
                ++first;
            }
        }

        patricia_set(patricia_set const &) = default;

        patricia_set(patricia_set &&) noexcept = default;

        auto operator=(patricia_set const &) -> patricia_set & = default;

        auto operator=(patricia_set &&) noexcept -> patricia_set & = default;

        auto clear() noexcept(std::is_nothrow_destructible_v<value_type>)
            -> void
        {
            _trie.clear();
        }

        [[nodiscard]] auto empty() const noexcept -> bool
        {
            return _trie.empty();
        }

        auto insert(value_type &&value) -> std::pair<iterator, bool>
        {
            auto node = _insert_node(value);

            SK_PATRICIA_INVARIANT(node != nullptr);

            if (node->value)
                return std::pair{iterator(node), false};

            node->value = std::move(value);
            return std::pair{iterator(node), true};
        }

        auto insert(value_type const &value) -> std::pair<iterator, bool>
        {
            auto node = _insert_node(value);

            SK_PATRICIA_INVARIANT(node != nullptr);

            if (node->value)
                return std::pair{iterator(node), false};

            node->value = value;
            return std::pair{iterator(node), true};
        }

        template <typename V>
        auto find(V const &key) noexcept -> iterator
        {
            auto node = _find_node(key);

            if (node && node->value.has_value())
                return iterator(node);

            return iterator();
        }

        template <typename V>
        auto find(V const &key) const noexcept -> const_iterator
        {
            auto node = _find_node(key);

            if (node && node->value.has_value())
                return const_iterator(node);

            return const_iterator();
        }

        auto prefix_match(value_type const &value) noexcept -> iterator
        {
            KeyMaker key_maker;
            auto key = key_maker(value);
            auto r = _trie.prefix_match(key);
            if (r)
                return iterator(r);
            else
                return end();
        }

        template <typename V>
        auto prefix_match(V const &value) noexcept -> iterator
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            auto r = _trie.prefix_match(key);
            if (r)
                return iterator(r);
            else
                return end();
        }

        template <typename V>
        auto prefix_match(V const &value) const noexcept -> const_iterator
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            auto r = _trie.prefix_match(key);
            if (r)
                return const_iterator(r);
            else
                return end();
        }

        template <typename V>
        auto contains(V const &key) const noexcept -> bool
        {
            auto node = _find_node(key);
            return node && node->value.has_value();
        }

        // Iterator operations.
        auto begin() noexcept -> iterator
        {
            return iterator(_trie.root_node());
        }

        auto begin() const noexcept -> const_iterator
        {
            return const_iterator(_trie.root_node());
        }

        auto cbegin() const noexcept -> const_iterator
        {
            return const_iterator(_trie.root_node());
        }

        auto end() noexcept -> iterator
        {
            return iterator();
        }

        auto end() const noexcept -> const_iterator
        {
            return const_iterator();
        }

        auto cend() const noexcept -> const_iterator
        {
            return const_iterator();
        }

        template <typename V>
        auto
        erase(V const &key) noexcept(std::is_nothrow_destructible_v<value_type>)
            -> size_type
        {
            auto node = _find_node(key);

            if (node && node->value.has_value()) {
                _trie.remove_node(node);
                return 1;
            }

            return 0;
        }

        auto
        erase(iterator pos) noexcept(std::is_nothrow_destructible_v<value_type>)
            -> void
        {
            _trie.remove_node(pos.get_node());
        }
    };

    /*************************************************************************
     *
     * patricia_map<K,T>: an std::map<>-type container using a patricia trie.
     */

    template <typename T, typename Alloc, bool is_const>
    class patricia_map_iterator {
        using iterator_type = patricia_iterator<T, Alloc, is_const>;
        using node_type = patricia_node<T, Alloc>;
        iterator_type current;

    public:
        using iterator_category = typename iterator_type::iterator_category;
        using difference_type = typename iterator_type::difference_type;
        using value_type = std::conditional_t<is_const, std::add_const_t<T>, T>;
        using const_value_type = std::add_const_t<value_type>;
        using pointer = value_type *;
        using const_pointer = const_value_type *;
        using reference = value_type &;
        using const_reference = const_value_type &;

        explicit patricia_map_iterator() noexcept = default;

        explicit patricia_map_iterator(node_type *node) noexcept
            : current(iterator_type(node))
        {
        }

        auto operator*() noexcept -> reference
        {
            return *current;
        }

        auto operator*() const noexcept -> const_reference
        {
            return *current;
        }

        auto operator->() noexcept -> pointer
        {
            return std::addressof(*current);
        }

        auto operator->() const noexcept -> const_pointer
        {
            return std::addressof(*current);
        }

        auto operator++() noexcept -> patricia_map_iterator &
        {
            ++current;
            return *this;
        }

        auto operator++(int) noexcept -> patricia_map_iterator
        {
            auto ret(*this);
            ++ret;
            return ret;
        }

        template <typename T_, typename Alloc_, bool is_const_>
        friend auto operator==(
            patricia_map_iterator<T_, Alloc_, is_const_> const &a,
            patricia_map_iterator<T_, Alloc_, is_const_> const &b) noexcept
            -> bool;
    };

    template <typename T, typename Alloc, bool is_const>
    auto operator==(patricia_map_iterator<T, Alloc, is_const> const &a,
                    patricia_map_iterator<T, Alloc, is_const> const &b) noexcept
        -> bool
    {
        return a.current == b.current;
    }

    template <typename K,
              typename T,
              typename KeyMaker = patricia_key_maker<K>,
              typename Alloc = std::allocator<std::pair<K, T>>>
    class patricia_map {
    public:
        using key_type = K;
        using value_type = std::pair<K, T>;
        using size_type = std::size_t;
        using difference_type = std::ptrdiff_t;
        using reference = value_type &;
        using const_reference = value_type const &;
        using pointer = typename std::allocator_traits<Alloc>::pointer;
        using const_pointer =
            typename std::allocator_traits<Alloc>::const_pointer;

        using iterator = patricia_map_iterator<value_type, Alloc, false>;
        using const_iterator = patricia_map_iterator<value_type, Alloc, true>;

    private:
        using trie_type = patricia_trie<value_type, Alloc>;
        using node_ptr = patricia_node<value_type, Alloc> *;
        using const_node_ptr = patricia_node<value_type, Alloc> const *;

        trie_type _trie;

        auto _insert_node(patricia_key const &key) -> node_ptr
        {
            return _trie.insert_node(key);
        }

        auto _insert_node(key_type const &value) -> node_ptr
        {
            KeyMaker key_maker;
            auto key = key_maker(value);
            return _insert_node(key);
        }

        template <typename V>
        auto _insert_node(V const &value) -> node_ptr
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            return _insert_node(key);
        }

        auto _find_node(patricia_key const &key) noexcept -> node_ptr
        {
            return _trie.find_node(key);
        }

        auto _find_node(patricia_key const &key) const noexcept
            -> const_node_ptr
        {
            return _trie.find_node(key);
        }

        template <typename V>
        auto _find_node(V const &value) noexcept -> node_ptr
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            return _find_node(key);
        }

        template <typename V>
        auto _find_node(V const &value) const noexcept -> const_node_ptr
        {
            typename KeyMaker::template rebind<V>::other key_maker;
            auto key = key_maker(value);
            return _find_node(key);
        }

    public:
        patricia_map() noexcept = default;
        ~patricia_map() noexcept(std::is_nothrow_destructible_v<trie_type>) =
            default;

        template <typename input_iterator>
        patricia_map(input_iterator first, input_iterator last)
        {
            while (first != last) {
                insert(*first);
                ++first;
            }
        }

        patricia_map(patricia_map const &) = default;

        patricia_map(patricia_map &&) noexcept = default;

        auto operator=(patricia_map const &) -> patricia_map & = default;

        auto operator=(patricia_map &&) noexcept -> patricia_map & = default;

        auto clear() const noexcept(std::is_nothrow_destructible_v<value_type>)
            -> void
        {
            _trie.clear();
        }

        [[nodiscard]] auto empty() const noexcept -> bool
        {
            return _trie.empty();
        }

        auto insert(value_type &&value) -> std::pair<iterator, bool>
        {
            auto node = _insert_node(value.first);

            SK_PATRICIA_INVARIANT(node != nullptr);

            if (node->value)
                return std::pair{iterator(node), false};

            node->value = std::move(value);
            return std::pair{iterator(node), true};
        }

        auto insert(value_type const &value) -> bool
        {
            auto node = _insert_node(value.first);

            SK_PATRICIA_INVARIANT(node != nullptr);

            if (node->value)
                return std::pair{iterator(node), false};

            node->value = value;
            return std::pair{iterator(node), true};
        }

        template <typename V>
        auto find(V const &key) noexcept -> iterator
        {
            auto node = _find_node(key);

            if (node && node->value.has_value())
                return iterator(node);

            return iterator();
        }

        template <typename V>
        auto find(V const &key) const noexcept -> const_iterator
        {
            auto node = _find_node(key);

            if (node && node->value.has_value())
                return const_iterator(node);

            return const_iterator();
        }

        template <typename V>
        auto contains(V const &key) const noexcept -> bool
        {
            auto node = _find_node(key);
            return node && node->value.has_value();
        }

        auto operator[](key_type const &k) -> T &
        {
            KeyMaker key_maker;
            auto key = key_maker(k);
            auto node = _trie.insert_node(key);

            if (!node->value)
                node->value.emplace(std::piecewise_construct,
                                    std::forward_as_tuple(k),
                                    std::tuple<>());

            return node->value->second;
        }

        // Iterator operations.
        auto begin() noexcept -> iterator
        {
            return iterator(_trie.root_node());
        }

        auto begin() const noexcept -> const_iterator
        {
            return const_iterator(_trie.root_node());
        }

        auto cbegin() const noexcept -> const_iterator
        {
            return const_iterator(_trie.root_node());
        }

        auto end() noexcept -> iterator
        {
            return iterator();
        }

        auto end() const noexcept -> const_iterator
        {
            return const_iterator();
        }

        auto cend() const noexcept -> const_iterator
        {
            return const_iterator();
        }

        template <typename V>
        auto
        erase(V const &key) noexcept(std::is_nothrow_destructible_v<value_type>)
            -> size_type
        {
            auto node = _find_node(key);

            if (node && node->value.has_value()) {
                _trie.remove_node(node);
                return 1;
            }

            return 0;
        }

        auto
        erase(iterator pos) noexcept(std::is_nothrow_destructible_v<value_type>)
            -> void
        {
            _trie.remove_node(pos.get_node());
        }
    };

} // namespace sk

#endif // SK_PATRICIA_HXX_INCLUDED
